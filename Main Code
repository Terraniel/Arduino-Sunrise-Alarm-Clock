// Sunrise/sunset Clock with display and 5 button control
//Hardware: Arduino Uno, DS3231 RTC, 1608 display with I2C adapter, 5 buttons (NO, momentary), 3 LED mosfets, RGB leds (or discrete) 
//
//Dan Bouchard 31Dec2022

//clock and timing libraries required
#include <DS3232RTC.h>
#include <Wire.h>
#include <time.h>

//creating real time clock object
DS3232RTC myRTC;

//pins assignments
const int snoozePin = 2;
const int menuPin = 3;
const int upPin = 4;
const int downPin = 5;
const int enterPin = 6;
const int LEDRed = 9;
const int LEDGreen = 10;
const int LEDBlue = 11;
//led variables
const int redMax = 255;
const int greenMax = 100;
const int blueMax = 80;
bool lightOn = false;
//sunset, and sunset variables
const int sunMax = 149;

int sunriseHour = 8;
int sunriseMinute = 0;
int sunriseLength = 60;
bool sunRising;
int sunsetHour = 21;
int sunsetMinute = 40;
float sunTime = 0;
int sunsetLength = 60;
bool sunSetting;
unsigned long sunMilliTimer = 0;
//button, menu, and clock variables
bool snoozing = false;
int BPSnooze;
int BPMenu;
int BPUp;
int BPDown;
int BPEnter;
bool BUSnooze = false;
bool BUMenu = false;
bool BUUp = false;
bool BUDown = false;
bool BUEnter = false;
bool menuMode = false;
unsigned long timeoutTimer = 0;
int timeoutTime = 10000;
int clockWrite = 0;
int menuIndex = 0;

//creating a button class to handle debounce and long press functions
class Button {
  private:
    const int debounceTimer = 10;
    const int longPressTimer = 1000;
    int btnPin = -1;
    int btnState;
    int lastBtnState;
    unsigned long pressStartTime = 0;
    bool latch = false;
  
    //Possible button states
  public: typedef enum ButtonStates {
    btnNotPressed,
    btnInDebounce,
    btnStartPressed,
    btnPressed,
    btnLongPressed
  };
  //button constructor
  Button(int pin) {
    btnPin = pin;
    pinMode(btnPin, INPUT);
    btnState = btnNotPressed;
    lastBtnState = btnNotPressed;
  }
  //button call back, for debounce and long press test
  void btnCallBack(void) {
    int pressed = digitalRead(btnPin);
    if (pressed == HIGH && btnState == btnNotPressed) {
      pressStartTime = millis();
      btnState = btnInDebounce;
    } else switch(btnState) {
      case btnInDebounce: //debounce timer currently disabled
        if ((millis() - pressStartTime) >= debounceTimer && pressed == HIGH) {
          btnState = btnStartPressed;
        }
        break;
      case btnStartPressed://starts counting for long press. a shorter release results in a short press
        if ((millis()-pressStartTime) >= longPressTimer && pressed == HIGH) {
          btnState = btnLongPressed;
        } else if ((millis()-pressStartTime) < longPressTimer && pressed == LOW) {
          btnState = btnPressed;
        }        
        break;
      case btnLongPressed:
        if (pressed == LOW) {
          btnState = btnNotPressed;
        }
        break;
      case btnPressed:
        if (pressed == LOW) {
          btnState = btnNotPressed;
        }
    }
  }
  // Returns only changed state outputs, otherwise gives btnNotPressed
  int btnOutput(void) {
    if (btnState != lastBtnState || btnState == btnLongPressed) {
      lastBtnState = btnState;
      if (btnState == btnNotPressed) latch = false; 
      return btnState;
    } else if (btnState == btnNotPressed) {
      latch = false;
      return btnNotPressed;
    }
  }
  void btnLatch(bool L) {
    latch = L;
  }
  //for comparison and latching purposes
  bool btnLatchOutput(void) {
    return latch;
  }
};

Button menuBtn(menuPin);
Button enterBtn(enterPin);
Button upBtn(upPin);
Button downBtn(downPin);
Button snoozeBtn(snoozePin);


//setup runs at startup.
//currently sets real time clock to compile time
void setup() {
  Serial.begin(9600);
  Serial.println("Setting Up");
  pinMode(LEDRed, OUTPUT);
  pinMode(LEDGreen, OUTPUT);
  pinMode(LEDBlue, OUTPUT);
  myRTC.begin();
  Serial.println("Clock started");
  setSyncProvider(myRTC.get);
  if(timeStatus() != timeSet) {
    Serial.println("Unable to sync with the RTC");
  } else {
    Serial.println("RTC has set the system time");
    Serial.println("Setup Complete");
  }
  timeFormatter();
  delay(1000);
}

//main loop - keeps track of button presses, calls sunrise and sunset checks
void loop() {
  time_t currentTime = now();
  buttonCheck();

  if (BPSnooze == Button::ButtonStates::btnPressed) snoozeLightSwitch();
  if (BPSnooze == Button::ButtonStates::btnLongPressed && !snoozeBtn.btnLatchOutput()) {
    snoozeBtn.btnLatch(true);
    Serial.println("LongSnooze");
    snooze();
  }

  if(BPMenu == Button::ButtonStates::btnPressed && !menuMode) {
    menuMode = true;
    timeoutTimer = millis();
    menu();
  }



  if (clockWrite == 5000 && !menuMode) {
    printDateTime(currentTime);
    clockWrite = 0;
  } else {
    clockWrite += 1;
  }
  sunAlarmCheck(currentTime);
  delay(1);
}
//quick button checker
void buttonCheck(void) {
  snoozeBtn.btnCallBack();
  menuBtn.btnCallBack();
  upBtn.btnCallBack();
  downBtn.btnCallBack();
  enterBtn.btnCallBack();

  BPSnooze = snoozeBtn.btnOutput();
  BPMenu = menuBtn.btnOutput();
  BPUp = upBtn.btnOutput();
  BPDown = downBtn.btnOutput();
  BPEnter = enterBtn.btnOutput();
}
//snooze button function, also functions as light switch when sun is not rising
void snooze() {
  if (sunRising && !snoozing){
    snoozing = true;
    Serial.println();
    Serial.println("Snoozing");
  } else if (sunRising && !snoozing) {
    Serial.println("Already snoozing!");
  } else if (sunSetting && !snoozing) {
    sunTime = 0;
    sunSetting = false;
    snoozing = false;
    writeSunColor();
    Serial.println("Goodnight!");
  } else snoozeLightSwitch();
}
//snooze button function to use long press as a light switch during sunrise or sunset
void snoozeLightSwitch() {
      if (lightOn) {
        switchLEDs(0, 0, 0);
        lightOn = false;
      }
      else if (!lightOn) {
        switchLEDs(redMax, greenMax, blueMax);
        lightOn = true;
      }
    }
void menu() {
  Serial.println("Menu");
  String menuItems[5] = {"Set Time", "Set Sunrise Time", "Set Sunrise Length", "Set Sunset Time", "Set Sunset Length"};
  Serial.println(menuItems[menuIndex]);
  while (menuMode){
    buttonCheck();  
    if(BPUp == Button::ButtonStates::btnPressed) {
      timeoutTimer = millis();
      if(menuIndex >= 4) menuIndex = 0;
      else menuIndex++;
      Serial.println(menuItems[menuIndex]);
    }
    if(BPDown == Button::ButtonStates::btnPressed) {
      timeoutTimer = millis();
      if(menuIndex <= 0) menuIndex = 4;
      else menuIndex--;
      Serial.println(menuItems[menuIndex]);
    }
    if (BPEnter == Button::ButtonStates::btnPressed && menuMode) {
      switch (menuIndex) {
        case 0:
          setClockTime();
          break;
        case 1:
          setSunClock(true);
          break;
        case 2:
          setSunLength(true);
          break;
        case 3:
          setSunClock(false);
          break;
        case 4:
        setSunLength(false);
        break;
      }
      menuMode = false;
    }
    if (millis()-timeoutTimer > timeoutTime && menuMode) {
      menuMode = false;
      Serial.println("Menu timed out.");
      return;
    }  
  }
}
//Sets Clock date and time
void setClockTime(void) {
  Serial.println("Clock Time cannot be set yet!");//build a clock time setter
  time_t ct = now();
  int timeDate[5] = {ct.hour(), ct.minute(), ct.day(), ct.month(), ct.year()};
  String tn[5] = {"Hour: ","Minute: ","Day: ","Month: ","Year: "};
  String msn[12] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
  bool entered = false;
  int tIndex = 0;
  Serial.print("Hour: ");
  Serial.println(timeDate[0]);
    while (entered == false && millis()-timeoutTimer<timeoutTime) {
    buttonCheck();
    if (BPMenu == Button::ButtonStates::btnPressed) {
      timeoutTimer = millis();
      return;
    }
    if (BPEnter == Button::ButtonStates::btnPressed) {
      timeoutTimer = millis();
      if (tIndex == 4) tIndex = 0;
      else tIndex++;
      Serial.print(tn[tIndex]);
      if (tIndex != 3) Serial.println(timeDate[tIndex]);
      else {
        Serial.println(msn[timeDate[tIndex]]);
      }
    }
    if (BPEnter == Button::ButtonStates::btnLongPressed) {
        Serial.print("Date and time set to: ");
        printDateTime();
        menuMode = false;
        entered = true;
        return;
    }
    if (BPUp == Button::ButtonStates::btnPressed || BPUp == Button::ButtonStates::btnLongPressed) {
      timeoutTimer = millis();
      if (hNM){
        if (nSH >= 23) nSH = 0;
        else nSH++; 
      } else {
        if (nSM >= 59) nSM = 0;
        else nSM++;          
      }
      if (riseNotSet) Serial.print("Sunrise");
      else Serial.print("Sunset");
      Serial.print(" new time:");
      print0X(nSH, ':');
      print0X(nSM, 0);
      Serial.println();
    }
    if (BPDown == Button::ButtonStates::btnPressed || BPDown == Button::ButtonStates::btnLongPressed) {
      timeoutTimer = millis();
      if (hNM){
        if (nSH <= 0) nSH = 23;
        else nSH--; 
      } else {
        if (nSM <= 0) nSM = 59;
        else nSM--;          
      }
      if (riseNotSet) Serial.print("Sunrise");
      else Serial.print("Sunset");
      Serial.print(" new time:");
      print0X(nSH, ':');
      print0X(nSM, 0);
      Serial.println();
    }
  }


}
//Sets sunset and sunrise times (pass true for sunrise, false for sunset)
void setSunClock(bool riseNotSet) {
  bool entered = false;
  bool hNM = true;
  int nSH = 0;
  int nSM = 0;
  if (riseNotSet) {
    nSH = sunriseHour;
    nSM = sunriseMinute;
    Serial.print("Sunrise time currently: ");
  }
  else {
    nSH = sunsetHour;
    nSM = sunsetMinute;
    Serial.print("Sunset time currently: ");
  }
  print0X(nSH, ':');
  print0X(nSM, 0);
  Serial.println();
  while (entered == false && millis()-timeoutTimer<timeoutTime) {
    buttonCheck();
    if (BPMenu == Button::ButtonStates::btnPressed) {
      timeoutTimer = millis();
      return;
    }
    if (BPEnter == Button::ButtonStates::btnPressed) {
      timeoutTimer = millis();
      if (hNM) hNM = false;
      else hNM = true;
    }
    if (BPEnter == Button::ButtonStates::btnLongPressed) {
        if (riseNotSet) {
          sunriseHour = nSH;
          sunriseMinute = nSM;
          Serial.print("Sunrise");
        } else {
          sunsetHour = nSH;
          sunsetMinute = nSM;
          Serial.print("Sunset");          
        }
        Serial.print(" time set to: ");
        print0X(nSH, ':');
        print0X(nSM, 0);
        Serial.println();
        menuMode = false;
        entered = true;
        return;
    }
    if (BPUp == Button::ButtonStates::btnPressed || BPUp == Button::ButtonStates::btnLongPressed) {
      timeoutTimer = millis();
      if (hNM){
        if (nSH >= 23) nSH = 0;
        else nSH++; 
      } else {
        if (nSM >= 59) nSM = 0;
        else nSM++;          
      }
      if (riseNotSet) Serial.print("Sunrise");
      else Serial.print("Sunset");
      Serial.print(" new time:");
      print0X(nSH, ':');
      print0X(nSM, 0);
      Serial.println();
    }
    if (BPDown == Button::ButtonStates::btnPressed || BPDown == Button::ButtonStates::btnLongPressed) {
      timeoutTimer = millis();
      if (hNM){
        if (nSH <= 0) nSH = 23;
        else nSH--; 
      } else {
        if (nSM <= 0) nSM = 59;
        else nSM--;          
      }
      if (riseNotSet) Serial.print("Sunrise");
      else Serial.print("Sunset");
      Serial.print(" new time:");
      print0X(nSH, ':');
      print0X(nSM, 0);
      Serial.println();
    }
  }
}
//checks current hour and minute against setpoints to decide if a sunrise or sunset needs to be started
//adjusts for sunset and sunrise lengths
void sunAlarmCheck(time_t currentTime) {
  int tNow = (hour(currentTime)*60+minute(currentTime));
  int sRT = (sunriseHour*60+sunriseMinute-sunriseLength);
  int sST = (sunsetHour*60+sunsetMinute-sunriseLength);
  if (clockWrite  == 500) {
  Serial.print("Time now: ");
  print0X(tNow/60, ':');
  print0X(tNow%60, 0);
  Serial.print(". Sunrise Start Time: ");
  print0X(sRT/60, ':');
  print0X(sRT%60, 0);
  Serial.print(". Sunset Start Time: ");
  print0X(sST/60, ':');
  print0X(sST%60, 0);
  Serial.println(".");
  }
  if (tNow == sRT && !sunRising && !lightOn && sunriseLength > 0) {
    sunMilliTimer = millis();
    sunRising = true;
    sunSetting = false;
    sunTime = 0;
    Serial.println("Sun is Rising");
  } else if (tNow == sST && !sunSetting && lightOn) {
    sunMilliTimer = millis();
    sunSetting = true;
    sunRising = false;
    sunTime = sunMax;
    lightOn = false;
    Serial.print("Sun is Setting ");
  }
  
  if(sunRising && !lightOn && sunsetLength > 0) {
    long sTR = long(sunriseLength*60000)+sunMilliTimer-millis();   
    sunrise(sTR);
  }
  if(sunSetting && !lightOn) {
    long sTR = long(sunsetLength*60000)+sunMilliTimer-millis();
    Serial.print("SunTime:");
    Serial.println(sunTime);
    sunset(sTR);
  }
}
//set sunrise or sunset length, to maximum of 120 minutes
//has a boolean to test for error message type
void setSunLength(bool riseNotSet) {
  timeoutTimer = millis();
  bool entered = false;
  float newSunLength;
  if (riseNotSet) {
    newSunLength = float(sunriseLength);
    Serial.print("Sunrise time in minutes: ");
  }
  else {
    newSunLength = sunsetLength;
    Serial.print("Sunset time in minutes:");
  }
  Serial.println(newSunLength);
  while (entered == false && millis()-timeoutTimer<timeoutTime) {
    buttonCheck();
    if (BPMenu == Button::ButtonStates::btnPressed) {
      timeoutTimer = millis();
      return;
    }
    if (BPEnter == Button::ButtonStates::btnPressed) {
      if (riseNotSet) {
        sunriseLength = int(newSunLength);
        Serial.print("Sunrise");
      }
      else if (!riseNotSet) {
        sunsetLength = newSunLength;
        Serial.print("Sunset");
      }
      Serial.print(" length set to: ");
      Serial.print(newSunLength);
      menuMode = false;
      entered = true;
      return;
    }
    if (newSunLength < 120) {
      if (BPUp == Button::ButtonStates::btnPressed) {
        timeoutTimer = millis();
        newSunLength++;
        Serial.print("Sunrise length, in minutes: ");
        Serial.println(newSunLength);
      }
      else if (BPUp == Button::ButtonStates::btnLongPressed) {
        timeoutTimer = millis();
        newSunLength++;
        Serial.print("Sunrise length, in minutes: ");
        Serial.println(newSunLength);
      }
    } else if (BPUp == Button::ButtonStates::btnLongPressed || BPUp == Button::ButtonStates::btnPressed) {
      timeoutTimer = millis();
      Serial.println("120 minutes is maximum!");
    }
    
    if (newSunLength > 0) {
      if  (BPDown == Button::ButtonStates::btnPressed) {
        timeoutTimer = millis();
        newSunLength--;
        Serial.print("Sunrise length, in minutes: ");
        Serial.println(newSunLength);
      }
      else if (BPDown == Button::ButtonStates::btnLongPressed) {
        timeoutTimer = millis();
        newSunLength--;
        Serial.print("Sunrise length, in minutes: ");
        Serial.println(newSunLength);
      }
    } else if (BPDown == Button::ButtonStates::btnLongPressed || BPDown == Button::ButtonStates::btnPressed) {
      timeoutTimer = millis();
      if (riseNotSet) Serial.println("Sunrise is turned off.");
      else Serial.println("Sunset is turned off.");
    }   
    
  }
}

//Color calculations based on formulas that are calibrated to a sunTime value of 155 maximum
//the -45 shifts the function to start the red curve at 0
//red is the dimmest color led, so it needs maximum final brightness
int colorCalcRed(float sunTime) {
  double x = sunTime;
  double mx = redMax;
  x = (sunTime-45);
  double C = mx-mx/(1+pow(1.15, x));
  int redVal = C;
  return max(0,redVal);
} 
//Color calculation for green. Needs to happen later than red. 
//The -80 will determine how much later after sunrise start.
//this will start turning the light orange (depends on greenMax)
int colorCalcGreen(float sunTime) {
  double x = sunTime;
  double mx = greenMax;
  x = (sunTime-80);
  double C = mx-mx/(1+pow(1.15, x));
  int greenVal = C;
  return max(0,greenVal);
}
//Color calculation for blue. Needs to happen later than green. 
//The -90 will determine how much later after sunrise start.
//this will start turning the light white (depends on blueMax)
int colorCalcBlue(float sunTime) {
  double x = sunTime;
  double mx = blueMax;
  x = (sunTime-90);
  double C = mx-mx/(1+pow(1.15, x));
  int blueVal = C;
  return max(0,blueVal);
}
//Writes the RGB values for sun color.
void writeSunColor() {
  int R = colorCalcRed(sunTime);
  int G = colorCalcGreen(sunTime);
  int B = colorCalcBlue(sunTime);
  switchLEDs(R, G, B);
}
//Simple LED output Writer
void switchLEDs (int R, int G, int B) {
  analogWrite(LEDRed, R);
  analogWrite(LEDGreen, G);
  analogWrite(LEDBlue, B);
} 
//checks for to make sure the sun is rising when it should be, and calculates the sun height
void sunrise(long sTR) {
  if(sunRising == true && lightOn == false) {
    if (sunTime<sunMax) {
      writeSunColor();
      if (snoozing) sunTime = float(sunMax)*(1.00-(float(sTR+10)/60000)/float(sunriseLength)); 
      else sunTime = float(sunMax)*(1-(float(sTR)/60000)/float(sunriseLength));
      //Serial.print(sunTime);
    } else {
      sunRising = false;
      snoozing = false;
      lightOn = true;      
      Serial.println();
      Serial.println("Sun has risen");
    }
  }
}
//checks to make sure the sun is setting when it should be and calculates the sun height
void sunset(long sTR) {
  if(sunSetting == true && lightOn == false) {
    if(sunTime>0) {
      writeSunColor();
      sunTime = float(sunMax)*((float(sTR)/60000)/float(sunsetLength));
      //Serial.print(sunTime);
    } else {
      sunSetting = false;
      lightOn = false;
      Serial.println();
      Serial.println("Sun has set");
    }
  }
}
//uses time object to get, set and write the time to/from rtc
void timeFormatter() {
  time_t t;
  tmElements_t tm;
  String CDate = __DATE__;
  String CTime = __TIME__;
  tm.Year = ((CDate.substring(9,11).toInt())+30);
  if (CDate.substring(4,4) == " ") tm.Day = (('0'+CDate.substring(4)).toInt());
  else tm.Day = CDate.substring(4,6).toInt();
  String CMo = CDate.substring(0,3);
  String msn[12] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
  for (int i=0; i<13; i++) {
    if (msn[i] == CMo) {
        tm.Month = (i+1);
      } else if (i ==13) {
      Serial.println("Month is undefined");
      }
    }
  tm.Hour = CTime.substring(0,2).toInt();
  tm.Minute = CTime.substring(3,5).toInt();
  tm.Second = CTime.substring(6).toInt();
  t = makeTime(tm);
  if (t>myRTC.get()) myRTC.set(t);
  setTime(t);
  Serial.print("RTC set to: ");
  printDateTime(t);
  Serial.println();
  
}

// print date and time
void printDateTime(time_t t) {
    printDate(t);
    Serial.print(' ');
    printTime24(t);
}

void printTime24(time_t t) {
    print0X(hour(t), ':');
    print0X(minute(t), ':');
    print0X(second(t), ' ');
    Serial.println();
}

void printDate(time_t t) {
    print0X(day(t), 0);
    Serial.print(" ");
    Serial.print(monthShortStr(month(t)));
    Serial.print(" ");
    Serial.print(year(t));
    Serial.print(" ");
}
//formatter for single digit times
void print0X(int val, char delim) {
    if (val < 10) Serial.print('0');
    Serial.print(val);
    if (delim > 0) Serial.print(delim);
    return;
}
