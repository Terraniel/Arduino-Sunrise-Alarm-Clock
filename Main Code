// Sunrise/sunset Clock with display and 5 button control
//Hardware: Arduino Uno, DS3231 RTC, 1608 display with I2C adapter, 5 buttons (NO, momentary), 3 LED mosfets, RGB leds (or discrete) 
//
//Dan Bouchard 31Dec2022

//clock and timing libraries required
#include <DS3232RTC.h>
#include <Wire.h>
#include <time.h>

//creating real time clock object
DS3232RTC myRTC;

//pins assignments
const int snoozePin = 2;
const int menuPin = 3;
const int upPin = 4;
const int downPin = 5;
const int enterPin = 6;
const int LEDRed = 9;
const int LEDGreen = 10;
const int LEDBlue = 11;
//led variables
const int redMax = 255;
const int greenMax = 100;
const int blueMax = 80;
bool lightOn = false;
//sunset, and sunset variables
const float sunMax = 149;
float sunTime;
int sunriseHour = 8;
int sunriseMinute = 00;
float sunriseLength = 60;
bool sunRising;
int sunsetHour = 21;
int sunsetMinute = 40;
float sunsetLength = 60;
bool sunSetting;
int timeCorrection = 4500;
unsigned long sunMilliTimer = 0;
//button, menu, and clock variables
float snoozeTime = 5;
bool snoozing = false;
int BPSnooze;
int BPMenu;
int BPUp;
int BPDown;
int BPEnter;
bool BUSnooze = false;
bool BUMenu = false;
bool BUUp = false;
bool BUDown = false;
bool BUEnter = false;
bool menuMode = false;
unsigned long timeoutTimer = 0;
int timeoutTime = 3000;
int clockWrite = 0;
int menuIndex = 0;
const String menuMenu[] = {"Set Sunrise Time","Set Sunrise Length","Set Sunset Time","Set Sunset Length","Set Time"};

//creating a button class to handle debounce and long press functions
class Button {
  private:
    const int debounceTimer = 20;
    const int longPressTimer = 1200;
    int btnPin = -1;
    int btnState;
    int lastBtnState;
    unsigned long pressStartTime = 0;
  
    //Possible button states
  public: typedef enum ButtonStates {
    btnNotPressed,
    btnInDebounce,
    btnStartPressed,
    btnPressed,
    btnLongPressed
  };

    //button constructor
  Button(int pin) {
    btnPin = pin;
    pinMode(btnPin, INPUT);
    btnState = btnNotPressed;
    lastBtnState = btnNotPressed;
  }

   //button call back, for debounce and long press test
  void btnCallBack(void) {
    int pressed = digitalRead(btnPin);
    if (pressed == HIGH && btnState == btnNotPressed) {
      pressStartTime = millis();
      btnState = btnStartPressed;
    } else switch(btnState) {
      case btnInDebounce: //debounce timer currently disabled
        if ((millis() - pressStartTime) >= debounceTimer && pressed == HIGH) {
          btnState = btnStartPressed;
        }
        break;
      case btnStartPressed://starts counting for long press. a shorter release results in a short press
        if ((millis()-pressStartTime) >= longPressTimer && pressed == HIGH) {
          btnState = btnLongPressed;
        } else if ((millis()-pressStartTime) < longPressTimer && pressed == LOW) {
          btnState = btnPressed;
        }        
        break;
      case btnLongPressed:
        if (pressed == LOW) {
          btnState = btnNotPressed;
        }
        break;
      case btnPressed:
        if (pressed == LOW) {
          btnState = btnNotPressed;
        }
    }
  }
  
 // Returns only changed state outputs, otherwise gives 0
  int btnOutput(void) {
    if (btnState != lastBtnState || btnState == btnLongPressed) {
      lastBtnState = btnState;   
      switch(btnState) {
        case btnNotPressed: return 0; break;
        case btnInDebounce: return 1; break;
        case btnStartPressed: return 2; break;
        case btnPressed: return 3; break;
        case btnLongPressed: return 4; break;
      }
    } //else return 0;
  }
};

Button menuBtn(menuPin);
Button enterBtn(enterPin);
Button upBtn(upPin);
Button downBtn(downPin);
Button snoozeBtn(snoozePin);


//setup runs at startup.
//currently sets real time clock to compile time
void setup() {
  Serial.begin(9600);
  Serial.println("Setting Up");
  pinMode(LEDRed, OUTPUT);
  pinMode(LEDGreen, OUTPUT);
  pinMode(LEDBlue, OUTPUT);
  myRTC.begin();
  Serial.println("Clock started");
  setSyncProvider(myRTC.get);
  if(timeStatus() != timeSet) {
    Serial.println("Unable to sync with the RTC");
  } else {
    Serial.println("RTC has set the system time");
    Serial.println("Setup Complete");
  }
  timeFormatter();
  delay(1000);
}

//main loop - keeps track of button presses, calls sunrise and sunset checks
void loop() {
  time_t currentTime = now();

  snoozeBtn.btnCallBack();
  menuBtn.btnCallBack();
  upBtn.btnCallBack();
  downBtn.btnCallBack();
  enterBtn.btnCallBack();

  BPSnooze = snoozeBtn.btnOutput();
  BPMenu = menuBtn.btnOutput();
  BPUp = upBtn.btnOutput();
  BPDown = downBtn.btnOutput();
  BPEnter = enterBtn.btnOutput();
  
  if (BPSnooze == 3) snooze();
  if (BPSnooze == 4) snoozeLightSwitch();

  if(BPMenu == 3 && menuMode == false) {
    Serial.println("Menu");
    menuMode = true;
    timeoutTimer = millis();
  }
  if (millis()-timeoutTimer > timeoutTime && menuMode == true) {
    menuMode = false;
    Serial.println("Menu timed out.");
  }

  if(BPUp == 3) {
    timeoutTimer = millis();
    Serial.println("Up");
  }

  if(BPDown == 3) {
    timeoutTimer = millis();
    Serial.print("Down");
  }

  if (BPEnter == 3 && menuMode == true) {
    Serial.println("Enter");
    menuMode = false;
  }

  if (clockWrite == 5000) {
    printDateTime(currentTime);
    clockWrite = 0;
  } else {
    clockWrite += 1;
  }
  sunAlarmCheck(currentTime);
  delay(1);
}
//snooze button function, also functions as light switch when sun is not rising
void snooze() {  
      if (sunRising == true && snoozing == false){
      sunTime -= (sunMax/sunriseLength*snoozeTime);
      snoozing = true;
      Serial.println();
      Serial.println("Snoozing");
    } else if (sunRising == true && snoozing == false) {
      Serial.println("Already snoozing!");
    } else if (sunSetting == true && snoozing == false) {
      sunTime = 0;
      sunSetting = false;
      snoozing = false;
      writeSunColor();
      Serial.println("Goodnight!");
    } else snoozeLightSwitch();
}

void snoozeLightSwitch() {
      if (lightOn) {
        switchLEDs(0, 0, 0);
        lightOn = false;
      }
      else if (!lightOn) {
        switchLEDs(redMax, greenMax, blueMax);
        lightOn = true;
      }
    }
void menu() {
  char * menuItems[5] = {"SET TIME", "SUNRISE TIME", "SUNSET TIME", "SUNRISE LENGTH", "SUNSET LENGTH"};

}
//checks current hour and minute against setpoints to decide if a sunrise or sunset needs to be started
//adjusts for sunset and sunrise lengths
void sunAlarmCheck(time_t currentTime) {
  int tNow = (hour(currentTime)*60+minute(currentTime));
  int sRT = (sunriseHour*60+sunriseMinute-sunriseLength);
  int sST = (sunsetHour*60+sunsetMinute-sunriseLength);
  if (clockWrite  == 500) {
  Serial.print("Time now: ");
  print0X(tNow/60, ':');
  print0X(tNow%60, 0);
  Serial.print(". Sunrise Start Time: ");
  print0X(sRT/60, ':');
  print0X(sRT%60, 0);
  Serial.print(". Sunset Start Time: ");
  print0X(sST/60, ':');
  print0X(sST%60, 0);
  Serial.println(".");
  }
  if (tNow == sRT && sunRising == false && lightOn == false) {
    sunMilliTimer = millis();
    sunRising = true;
    sunSetting = false;
    sunTime = 0;
    Serial.println("Sun is Rising");
  } else if (tNow == sST && sunSetting == false && lightOn == true) {
    sunMilliTimer = millis();
    sunSetting = true;
    sunRising = false;
    sunTime = sunMax;
    lightOn = false;
    Serial.print("Sun is Setting ");
  }
  
  if(sunRising == true) {
    long sTR = long(sunriseLength*60000)+sunMilliTimer-millis();   
    sunrise(sTR);
  }
  if(sunSetting == true) {
    long sTR = long(sunsetLength*60000)+sunMilliTimer-millis();
    Serial.print("SunTime:");
    Serial.println(sunTime);
    sunset(sTR);
  }
}
//set suhnrise or sunset length, to maximum of 120 minutes
//has a boolean to test for error message type
int setSunLength(bool riseNotSet) {
  timeoutTimer = millis();
  bool entered = false;
  float newSunLength = sunriseLength;
  while (entered == false && millis()-timeoutTimer<timeoutTime) {
    BPMenu = menuBtn.btnOutput();
    BPUp = upBtn.btnOutput();
    BPDown = downBtn.btnOutput();
    BPEnter = enterBtn.btnOutput();
    if (BPMenu ==3) return sunriseLength;
    if (BPEnter == 3 || BPEnter == 4) {
      sunriseLength = newSunLength;
      menuMode = false;
      entered == false;
      return sunriseLength;
    }
    if (newSunLength < 120) {
      if (BPUp == 3) newSunLength++;
      else if (BPUp == 4) newSunLength++; 
      else Serial.println("120 is maximum!");
    }
    if (newSunLength > -1) {
      if  (BPDown == 3) newSunLength--;
      else if (BPDown == 4) newSunLength--;
      else {
        if (riseNotSet) Serial.println("Sunrise is turned off.");
        else Serial.println("Sunset is turned off.");
      }   
    }
  }
}

//Color calculations based on formulas that are calibrated to a sunTime value of 155 maximum
//the -45 shifts the function to start the red curve at 0
//red is the dimmest color led, so it needs maximum final brightness
int colorCalcRed(float sunTime) {
  double x = sunTime;
  double mx = redMax;
  x = (sunTime-45);
  double C = mx-mx/(1+pow(1.15, x));
  int redVal = C;
  return max(0,redVal);
} 
//Color calculation for green. Needs to happen later than red. 
//The -80 will determine how much later after sunrise start.
//this will start turning the light orange (depends on greenMax)
int colorCalcGreen(float sunTime) {
  double x = sunTime;
  double mx = greenMax;
  x = (sunTime-80);
  double C = mx-mx/(1+pow(1.15, x));
  int greenVal = C;
  return max(0,greenVal);
}
//Color calculation for blue. Needs to happen later than green. 
//The -90 will determine how much later after sunrise start.
//this will start turning the light white (depends on blueMax)
int colorCalcBlue(float sunTime) {
  double x = sunTime;
  double mx = blueMax;
  x = (sunTime-90);
  double C = mx-mx/(1+pow(1.15, x));
  int blueVal = C;
  return max(0,blueVal);
}
//Writes the RGB values for sun color.
void writeSunColor() {
  int R = colorCalcRed(sunTime);
  int G = colorCalcGreen(sunTime);
  int B = colorCalcBlue(sunTime);
  switchLEDs(R, G, B);
}
//Simple LED output Writer
void switchLEDs (int R, int G, int B) {
  analogWrite(LEDRed, R);
  analogWrite(LEDGreen, G);
  analogWrite(LEDBlue, B);
} 
//checks for to make sure the sun is rising when it should be, and calculates the sun height
void sunrise(long sTR) {
  if(sunRising == true && lightOn == false) {
    if (sunTime<sunMax) {
      writeSunColor();
      sunTime = sunMax*(1-(float(sTR)/60000)/sunriseLength);
      //Serial.print(sunTime);
    } else {
      sunRising = false;
      snoozing = false;
      lightOn = true;      
      Serial.println();
      Serial.println("Sun has risen");
    }
  }
}
//checks to make sure the sun is setting when it should be and calculates the sun height
void sunset(long sTR) {
  if(sunSetting == true && lightOn == false) {
    if(sunTime>0) {
      writeSunColor();
      sunTime = sunMax*((float(sTR)/60000)/sunsetLength);
      //Serial.print(sunTime);
    } else {
      sunSetting = false;
      lightOn = false;
      Serial.println();
      Serial.println("Sun has set");
    }
  }
}

void timeFormatter() {
  time_t t;
  tmElements_t tm;
  String CDate = __DATE__;
  String CTime = __TIME__;
  tm.Year = ((CDate.substring(9,11).toInt())+30);
  if (CDate.substring(4,4) == " ") tm.Day = (('0'+CDate.substring(4)).toInt());
  else tm.Day = CDate.substring(4,6).toInt();
  String CMo = CDate.substring(0,3);
  String dateArray[12] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
  for (int i=0; i<13; i++) {
    if (dateArray[i] == CMo) {
        tm.Month = (i+1);
      } else if (i ==13) {
      Serial.println("Month is undefined");
      }
    }
  tm.Hour = CTime.substring(0,2).toInt();
  tm.Minute = CTime.substring(3,5).toInt();
  tm.Second = CTime.substring(6).toInt();
  t = makeTime(tm);
  if (t>myRTC.get()) myRTC.set(t);
  setTime(t);
  Serial.print("RTC set to: ");
  printDateTime(t);
  Serial.println();
  
}

// print date and time
void printDateTime(time_t t) {
    printDate(t);
    Serial.print(' ');
    printTime24(t);
}

void printTime24(time_t t) {
    print0X(hour(t), ':');
    print0X(minute(t), ':');
    print0X(second(t), ' ');
    Serial.println();
}

void printDate(time_t t) {
    print0X(day(t), 0);
    Serial.print(" ");
    Serial.print(monthShortStr(month(t)));
    Serial.print(" ");
    Serial.print(year(t));
    Serial.print(" ");
}
//formatter for single digit times
void print0X(int val, char delim) {
    if (val < 10) Serial.print('0');
    Serial.print(val);
    if (delim > 0) Serial.print(delim);
    return;
}
